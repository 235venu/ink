<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Entry point for writing ink! smart contracts."><meta name="keywords" content="rust, rustlang, rust-lang, contract"><title>contract in ink_lang_macro - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../ink_lang_macro/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../ink_lang_macro/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In ink_lang_macro</a></h2><div id="sidebar-vars" data-name="contract" data-ty="attr" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../ink_lang_macro/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Attribute Macro <a href="index.html">ink_lang_macro</a>::<wbr><a class="attr" href="#">contract</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/ink_lang_macro/lib.rs.html#532-534">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust attr"><code>#[contract]</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Entry point for writing ink! smart contracts.</p>
<p>If you are a beginner trying to learn ink! we recommend you to check out
our extensive <a href="https://docs.substrate.io/tutorials/v3/ink-workshop/pt1">ink! workshop</a>.</p>
<p><strong>Note:</strong> In all below examples we will be using <code>ink_lang</code> crate aliased as just <code>ink</code>.
You can do this yourself by adding the following line to your code:
<code>use ink_lang as ink;</code></p>
<h2 id="description"><a href="#description">Description</a></h2>
<p>The macro does analysis on the provided smart contract code and generates
proper code.</p>
<p>ink! smart contracts can compile in several different modes.
There are two main compilation models using either</p>
<ul>
<li>on-chain mode: <code>no_std</code> and WebAssembly as target</li>
<li>off-chain mode: <code>std</code></li>
</ul>
<p>We generally use the on-chain mode for actual smart contract instantiation
whereas we use the off-chain mode for smart contract testing using the
off-chain environment provided by the <code>ink_env</code> crate.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2><h3 id="header-arguments"><a href="#header-arguments">Header Arguments</a></h3>
<p>The <code>#[ink::contract]</code> macro can be provided with some additional comma-separated
header arguments:</p>
<ul>
<li>
<p><code>keep_attr: String</code></p>
<p>Tells the ink! code generator which attributes should be passed to call builders.
Call builders are used to doing cross-contract calls and are automatically
generated for contracts.</p>
<p><strong>Usage Example:</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">ink::contract</span>(<span class="ident">keep_attr</span> <span class="op">=</span> <span class="string">&quot;foo, bar&quot;</span>)]</span>
<span class="kw">mod</span> <span class="ident">my_contract</span> {
    <span class="comment">//    #[bar]</span>
    <span class="comment">//    #[foo]</span>
    <span class="comment">// ...</span>
}</code></pre></div>
<p><strong>Allowed attributes by default:</strong> <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code>,
<code>deprecated</code>, <code>must_use</code>, <code>doc</code>, <code>rustfmt</code>.</p>
</li>
<li>
<p><code>env: impl Environment</code></p>
<p>Tells the ink! code generator which environment to use for the ink! smart contract.
The environment must implement the <code>Environment</code> (defined in <code>ink_env</code>) trait and provides
all the necessary fundamental type definitions for <code>Balance</code>, <code>AccountId</code> etc.</p>
<p>When using a custom <code>Environment</code> implementation for a smart contract all types
that it exposes to the ink! smart contract and the mirrored types used in the runtime
must be aligned with respect to SCALE encoding and semantics.</p>
<p><strong>Usage Example:</strong></p>
<p>Given a custom <code>Environment</code> implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyEnvironment</span>;

<span class="kw">impl</span> <span class="ident">ink_env::Environment</span> <span class="kw">for</span> <span class="ident">MyEnvironment</span> {
    <span class="kw">const</span> <span class="ident">MAX_EVENT_TOPICS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">3</span>;
    <span class="kw">type</span> <span class="ident">AccountId</span> <span class="op">=</span> [<span class="ident">u8</span>; <span class="number">16</span>];
    <span class="kw">type</span> <span class="ident">Balance</span> <span class="op">=</span> <span class="ident">u128</span>;
    <span class="kw">type</span> <span class="ident">Hash</span> <span class="op">=</span> [<span class="ident">u8</span>; <span class="number">32</span>];
    <span class="kw">type</span> <span class="ident">Timestamp</span> <span class="op">=</span> <span class="ident">u64</span>;
    <span class="kw">type</span> <span class="ident">BlockNumber</span> <span class="op">=</span> <span class="ident">u32</span>;
    <span class="kw">type</span> <span class="ident">ChainExtension</span> <span class="op">=</span> <span class="ident">::ink_env::NoChainExtension</span>;
}</code></pre></div>
<p>A user might implement their ink! smart contract using the above custom <code>Environment</code>
implementation as demonstrated below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">ink::contract</span>(<span class="ident">env</span> <span class="op">=</span> <span class="ident">MyEnvironment</span>)]</span>
<span class="kw">mod</span> <span class="ident">my_contract</span> {
    <span class="comment">// ...</span>
}</code></pre></div>
<p><strong>Default value:</strong> <code>DefaultEnvironment</code> defined in <code>ink_env</code> crate.</p>
</li>
</ul>
<h3 id="analysis"><a href="#analysis">Analysis</a></h3>
<p>The <code>#[ink::contract]</code> macro fully analyses its input smart contract
against invalid arguments and structure.</p>
<p>Some example rules include but are not limited to:</p>
<ul>
<li>
<p>There must be exactly one <code>#[ink(storage)]</code> struct.</p>
<p>This struct defines the layout of the storage that the ink! smart contract operates on.
The user is able to use a variety of built-in facilities, combine them in various ways
or even provide their own implementations of storage data structures.</p>
<p>For more information visit the <code>ink_storage</code> crate documentation.</p>
<p><strong>Example:</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">ink::contract</span>]</span>
<span class="kw">mod</span> <span class="ident">flipper</span> {
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">storage</span>)]</span>
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Flipper</span> {
        <span class="ident">value</span>: <span class="ident">bool</span>,
    }
}</code></pre></div>
</li>
<li>
<p>There must be at least one <code>#[ink(constructor)]</code> defined method.</p>
<p>Methods flagged with <code>#[ink(constructor)]</code> are special in that they are dispatchable
upon contract instantiation. A contract may define multiple such constructors which
allow users of the contract to instantiate a contract in multiple different ways.</p>
<p><strong>Example:</strong></p>
<p>Given the <code>Flipper</code> contract definition above we add an <code>#[ink(constructor)]</code>
as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Flipper</span> {
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">constructor</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">initial_value</span>: <span class="ident">bool</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">Flipper</span> { <span class="ident">value</span>: <span class="bool-val">false</span> }
    }
}</code></pre></div>
</li>
<li>
<p>There must be at least one <code>#[ink(message)]</code> defined method.</p>
<p>Methods flagged with <code>#[ink(message)]</code> are special in that they are dispatchable
upon contract invocation. The set of ink! messages defined for an ink! smart contract
define its API surface with which users are allowed to interact.</p>
<p>An ink! smart contract can have multiple such ink! messages defined.</p>
<p><strong>Note:</strong></p>
<ul>
<li>An ink! message with a <code>&amp;self</code> receiver may only read state whereas an ink! message
with a <code>&amp;mut self</code> receiver may mutate the contract’s storage.</li>
</ul>
<p><strong>Example:</strong></p>
<p>Given the <code>Flipper</code> contract definition above we add some <code>#[ink(message)]</code> definitions
as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Flipper</span> {
    <span class="doccomment">/// Flips the current value.</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">flip</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">value</span> <span class="op">=</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">value</span>;
    }

    <span class="doccomment">/// Returns the current value.</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">value</span>
    }
}</code></pre></div>
<p><strong>Payable Messages:</strong></p>
<p>An ink! message by default will reject calls that additional fund the smart contract.
Authors of ink! smart contracts can make an ink! message payable by adding the <code>payable</code>
flag to it. An example below:</p>
<p>Note that ink! constructors are always implicitly payable and thus cannot be flagged
as such.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Flipper</span> {
    <span class="doccomment">/// Flips the current value.</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>)]</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">payable</span>)]</span> <span class="comment">// You can either specify payable out-of-line.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">flip</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">value</span> <span class="op">=</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">value</span>;
    }

    <span class="doccomment">/// Returns the current value.</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>, <span class="ident">payable</span>)]</span> <span class="comment">// ...or specify payable inline.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">value</span>
    }
}</code></pre></div>
<p><strong>Controlling the messages selector:</strong></p>
<p>Every ink! message and ink! constructor has a unique selector with which the
message or constructor can be uniquely identified within the ink! smart contract.
These selectors are mainly used to drive the contract’s dispatch upon calling it.</p>
<p>An ink! smart contract author can control the selector of an ink! message or ink!
constructor using the <code>selector</code> flag. An example is shown below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Flipper</span> {
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">constructor</span>)]</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">selector</span> <span class="op">=</span> <span class="number">0xDEADBEEF</span>)]</span> <span class="comment">// Works on constructors as well.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">initial_value</span>: <span class="ident">bool</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">Flipper</span> { <span class="ident">value</span>: <span class="bool-val">false</span> }
    }

    <span class="doccomment">/// Returns the current value.</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>, <span class="ident">selector</span> <span class="op">=</span> <span class="number">0xFEEDBEEF</span>)]</span> <span class="comment">// ...or specify selector inline.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">value</span>
    }
}</code></pre></div>
</li>
</ul>
<h3 id="interacting-with-the-contract-executor"><a href="#interacting-with-the-contract-executor">Interacting with the Contract Executor</a></h3>
<p>The <code>ink_env</code> crate provides facilities to interact with the contract executor that
connects ink! smart contracts with the outer world.</p>
<p>For example it is possible to query the current call’s caller via:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">caller</span> <span class="op">=</span> <span class="ident">ink_env::caller</span>::<span class="op">&lt;</span><span class="ident">ink_env::DefaultEnvironment</span><span class="op">&gt;</span>();</code></pre></div>
<p>However, ink! provides a much simpler way to interact with the contract executor
via its environment accessor. An example below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">ink::contract</span>]</span>
<span class="kw">mod</span> <span class="ident">greeter</span> {
    <span class="kw">use</span> <span class="ident">ink_env::debug_println</span>;

    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">storage</span>)]</span>
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Greeter</span>;

    <span class="kw">impl</span> <span class="ident">Greeter</span> {
        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">constructor</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() -&gt; <span class="self">Self</span> {
            <span class="kw">let</span> <span class="ident">caller</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::env</span>().<span class="ident">caller</span>();
            <span class="macro">debug_println!</span>(<span class="string">&quot;thanks for instantiation {:?}&quot;</span>, <span class="ident">caller</span>);
            <span class="ident">Greeter</span> {}
        }

        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>, <span class="ident">payable</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">fund</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
            <span class="kw">let</span> <span class="ident">caller</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">env</span>().<span class="ident">caller</span>();
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">env</span>().<span class="ident">transferred_value</span>();
            <span class="macro">debug_println!</span>(<span class="string">&quot;thanks for the funding of {:?} from {:?}&quot;</span>, <span class="ident">value</span>, <span class="ident">caller</span>);
        }
    }
}</code></pre></div>
<h3 id="events"><a href="#events">Events</a></h3>
<p>An ink! smart contract may define events that it can emit during contract execution.
Emitting events can be used by third party tools to query information about a contract’s
execution and state.</p>
<p>The following example ink! contract shows how an event <code>Transferred</code> is defined and
emitted in the <code>#[ink(constructor)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">ink::contract</span>]</span>
<span class="kw">mod</span> <span class="ident">erc20</span> {
    <span class="doccomment">/// Defines an event that is emitted every time value is transferred.</span>
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">event</span>)]</span>
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Transferred</span> {
        <span class="ident">from</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">AccountId</span><span class="op">&gt;</span>,
        <span class="ident">to</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">AccountId</span><span class="op">&gt;</span>,
        <span class="ident">value</span>: <span class="ident">Balance</span>,
    }

    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">storage</span>)]</span>
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Erc20</span> {
        <span class="ident">total_supply</span>: <span class="ident">Balance</span>,
        <span class="comment">// more fields...</span>
    }

    <span class="kw">impl</span> <span class="ident">Erc20</span> {
        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">constructor</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">initial_supply</span>: <span class="ident">Balance</span>) -&gt; <span class="self">Self</span> {
            <span class="kw">let</span> <span class="ident">caller</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::env</span>().<span class="ident">caller</span>();
            <span class="ident"><span class="self">Self</span>::env</span>().<span class="ident">emit_event</span>(<span class="ident">Transferred</span> {
                <span class="ident">from</span>: <span class="prelude-val">None</span>,
                <span class="ident">to</span>: <span class="prelude-val">Some</span>(<span class="ident">caller</span>),
                <span class="ident">value</span>: <span class="ident">initial_supply</span>,
            });
            <span class="self">Self</span> { <span class="ident">total_supply</span>: <span class="ident">initial_supply</span> }
        }

        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">total_supply</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Balance</span> {
            <span class="self">self</span>.<span class="ident">total_supply</span>
        }
    }
}</code></pre></div>
<h3 id="example-flipper"><a href="#example-flipper">Example: Flipper</a></h3>
<p>The below code shows the complete implementation of the so-called Flipper
ink! smart contract.
For us it acts as the “Hello, World!” of the ink! smart contracts because
it is minimal while still providing some more or less useful functionality.</p>
<p>It controls a single <code>bool</code> value that can be either <code>false</code> or <code>true</code>
and allows the user to flip this value using the <code>Flipper::flip</code> message
or retrieve the current value using <code>Flipper::get</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">ink_lang</span> <span class="kw">as</span> <span class="ident">ink</span>;

<span class="attribute">#[<span class="ident">ink::contract</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">flipper</span> {
    <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">storage</span>)]</span>
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Flipper</span> {
        <span class="ident">value</span>: <span class="ident">bool</span>,
    }

    <span class="kw">impl</span> <span class="ident">Flipper</span> {
        <span class="doccomment">/// Creates a new flipper smart contract initialized with the given value.</span>
        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">constructor</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">init_value</span>: <span class="ident">bool</span>) -&gt; <span class="self">Self</span> {
            <span class="self">Self</span> { <span class="ident">value</span>: <span class="ident">init_value</span> }
        }

        <span class="doccomment">/// Flips the current value of the Flipper&#39;s boolean.</span>
        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">flip</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
            <span class="self">self</span>.<span class="ident">value</span> <span class="op">=</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">value</span>;
        }

        <span class="doccomment">/// Returns the current value of the Flipper&#39;s boolean.</span>
        <span class="attribute">#[<span class="ident">ink</span>(<span class="ident">message</span>)]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
            <span class="self">self</span>.<span class="ident">value</span>
        }
    }
}</code></pre></div>
</div></details></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="ink_lang_macro" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0-nightly (082e4ca49 2022-04-26)" ></div>
</body></html>